<!-- build time:Wed Jul 22 2020 01:11:31 GMT+0800 (中国标准时间) --><!DOCTYPE html><html class="theme-next gemini" lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><link rel="stylesheet" href="/lib/needsharebutton/needsharebutton.css"><script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script><link rel="stylesheet" href="//cdn.bootcss.com/pace/1.0.2/themes/blue/pace-theme-flash.min.css"><link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css"><link rel="stylesheet" href="/css/main.css?v=6.7.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/128x128.png?v=6.7.0"><link rel="icon" type="image/png" sizes="32x32" href="/images/32x32.png?v=6.7.0"><link rel="icon" type="image/png" sizes="16x16" href="/images/16x16.png?v=6.7.0"><link rel="mask-icon" href="/images/logo2.svg?v=6.7.0" color="#222"><script id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Gemini",version:"6.7.0",sidebar:{position:"left",display:"post",offset:12,b2t:!0,scrollpercent:!0,onmobile:!1},fancybox:!1,fastclick:!0,lazyload:!0,tabs:!0,motion:{enable:!1,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><script>!function(e,t,o,c,i,a,n){e.DaoVoiceObject=i,e[i]=e[i]||function(){(e[i].q=e[i].q||[]).push(arguments)},e[i].l=1*new Date,a=t.createElement(o),n=t.getElementsByTagName(o)[0],a.async=1,a.src=c,a.charset="utf-8",n.parentNode.insertBefore(a,n)}(window,document,"script",("https:"==document.location.protocol?"https:":"http:")+"//widget.daovoice.io/widget/8f5c5484.js","daovoice"),daovoice("init",{app_id:"8f5c5484"}),daovoice("update")</script><meta name="description" content="前言核相关滤波算法是单目标跟踪领域一个举足轻重的算法，而kernelized correlation filters(KCF)是其原始形态，下面我以一个小白的角度慢慢揭开其神秘面纱。"><meta name="keywords" content="目标跟踪,KCF"><meta property="og:type" content="article"><meta property="og:title" content="剖析KCF"><meta property="og:url" content="https://huangpiao.tech/2019/02/04/剖析KCF/index.html"><meta property="og:site_name" content="见渊の博客"><meta property="og:description" content="前言核相关滤波算法是单目标跟踪领域一个举足轻重的算法，而kernelized correlation filters(KCF)是其原始形态，下面我以一个小白的角度慢慢揭开其神秘面纱。"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="https://blogdata-1258545379.cos.ap-shanghai.myqcloud.com/20190201/1549029068783.png"><meta property="og:image" content="https://blogdata-1258545379.cos.ap-shanghai.myqcloud.com/20190201/1549042686678.png"><meta property="og:image" content="https://blogdata-1258545379.cos.ap-shanghai.myqcloud.com/20190201/1549204757681.png"><meta property="og:image" content="https://blogdata-1258545379.cos.ap-shanghai.myqcloud.com/20190201/1549265609508.png"><meta property="og:image" content="https://blogdata-1258545379.cos.ap-shanghai.myqcloud.com/20190201/1549270523031.png"><meta property="og:image" content="https://blogdata-1258545379.cos.ap-shanghai.myqcloud.com/20190201/1549270624282.png"><meta property="og:image" content="https://blogdata-1258545379.cos.ap-shanghai.myqcloud.com/20190201/1549271000831.png"><meta property="og:image" content="https://blogdata-1258545379.cos.ap-shanghai.myqcloud.com/20190201/5252065-a0c76ca30c0acf6f.webp"><meta property="og:image" content="https://blogdata-1258545379.cos.ap-shanghai.myqcloud.com/20190201/20180820160426679"><meta property="og:image" content="https://blogdata-1258545379.cos.ap-shanghai.myqcloud.com/20190201/1549286021525.png"><meta property="og:updated_time" content="2019-02-04T14:00:00.000Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="剖析KCF"><meta name="twitter:description" content="前言核相关滤波算法是单目标跟踪领域一个举足轻重的算法，而kernelized correlation filters(KCF)是其原始形态，下面我以一个小白的角度慢慢揭开其神秘面纱。"><meta name="twitter:image" content="https://blogdata-1258545379.cos.ap-shanghai.myqcloud.com/20190201/1549029068783.png"><link rel="alternate" href="/atom.xml" title="见渊の博客" type="application/atom+xml"><link rel="canonical" href="https://huangpiao.tech/2019/02/04/剖析KCF/"><script id="page.configurations">CONFIG.page={sidebar:""}</script><title>剖析KCF | 见渊の博客</title><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-title,.use-motion .comments,.use-motion .menu-item,.use-motion .motion-element,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .logo,.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN"><div class="container sidebar-position-left page-post-detail"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">见渊の博客</span> <span class="logo-line-after"><i></i></span></a></div></div><div class="site-nav-toggle"><button aria-label="切换导航栏"><span class="btn-bar"></span> <span class="btn-bar"></span> <span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i><br>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i><br>标签<span class="badge">49</span></a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i><br>分类<span class="badge">16</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br>归档<span class="badge">44</span></a></li><li class="menu-item menu-item-search"><a href="javascript:;" class="popup-trigger"><i class="menu-item-icon fa fa-search fa-fw"></i><br>搜索</a></li></ul><div class="site-search"><div class="popup search-popup local-search-popup"><div class="local-search-header clearfix"><span class="search-icon"><i class="fa fa-search"></i> </span><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span><div class="local-search-input-wrapper"><input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input"></div></div><div id="local-search-result"></div></div></div></nav></div></header><a href="https://github.com/nightmaredimple" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewbox="0 0 250 250" style="fill:#222;color:#fff;position:absolute;top:0;border:0;right:0" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"/><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"/><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"/></svg></a><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><div class="reading-progress-bar"></div><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://huangpiao.tech/2019/02/04/剖析KCF/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="黄飘"><meta itemprop="description" content="直到这一刻微笑着说话为止，我至少留下了一公升眼泪"><meta itemprop="image" content="/images/author.jpg"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="见渊の博客"></span><header class="post-header"><h2 class="post-title" itemprop="name headline">剖析KCF</h2><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2019-02-04 22:00:00" itemprop="dateCreated datePublished" datetime="2019-02-04T22:00:00+08:00">2019-02-04</time> </span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/机器学习/" itemprop="url" rel="index"><span itemprop="name">机器学习</span></a></span> ， <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/机器学习/目标跟踪/" itemprop="url" rel="index"><span itemprop="name">目标跟踪</span></a></span> </span><span class="post-comments-count"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-comment-o"></i> </span><a href="/2019/02/04/剖析KCF/#comments" itemprop="discussionUrl"><span class="post-meta-item-text">评论数：</span> <span class="post-comments-count valine-comment-count" data-xid="/2019/02/04/剖析KCF/" itemprop="commentCount"></span> </a></span><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-eye"></i> 阅读次数： <span class="busuanzi-value" id="busuanzi_value_page_pv"></span></span><div class="post-symbolscount"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i> </span><span class="post-meta-item-text">本文字数：</span><span title="本文字数">8.9k字</span></div></div></header><div class="post-body" itemprop="articleBody"><hr><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>核相关滤波算法是单目标跟踪领域一个举足轻重的算法，而kernelized correlation filters(KCF)是其原始形态，下面我以一个小白的角度慢慢揭开其神秘面纱。</p></blockquote><a id="more"></a><h2 id="1-岭回归理论推导"><a href="#1-岭回归理论推导" class="headerlink" title="1.岭回归理论推导"></a>1.岭回归理论推导</h2><p>岭回归的理论比较简单，类似于一个单层神经网络加上一个正则项，不同于支撑向量机中的结构风险最小化，岭回归更像是一个逻辑回归，是在保证误差风险最小的情况下尽量使得结构风险小。另外支撑向量机对于高维数据的训练比较快，因为它只取对分类有影响的 support 向量。不过在此处 KCF 的训练样本也不多，所以二者其实都可以，再加上 KCF 中岭回归还引用了对偶空间、傅里叶变换以及核函数，二者的差别就比较小了。<br>​ 岭回归的算法形式如下：</p><script type="math/tex;mode=display">\mathop {\min }\limits_w \sum\limits_i {{{\left( {f\left( {{x_i}} \right) - {y_i}} \right)}^2} + \lambda {{\left\| w \right\|}^2}}  \Leftrightarrow \mathop {\min }\limits_w \sum\limits_i {{{\left( {Xw - y} \right)}^2} + \lambda {{\left\| w \right\|}^2}}\tag{1-1}</script><p>其中<em>X</em> 为特征矩阵，<em>w</em> 为权值，<em>y</em> 为样本标签/响应，其中每一项都采用了<em>L</em>2 范数的平方,即矩阵内所有元素的平方和。因此，该优化的关键在于求最优的 <em>w</em>，求解方法则是使用了最直接的拉格朗日乘子法：</p><script type="math/tex;mode=display">\begin{array}{l}
\because L = {\left( {Xw - y} \right)^T}\left( {Xw - y} \right) + \lambda {w^T}w\\
\;\;\;\;\;\; = \left( {{w^T}{X^T} - {y^T}} \right)\left( {Xw - y} \right) + \lambda {w^T}w\\
\;\;\;\;\;\; = {w^T}{X^T}Xw - {y^T}Xw - {w^T}{X^T}y + {y^T}y + \lambda {w^T}w\\
\therefore \frac{{\partial L}}{{\partial w}} = 2{X^T}Xw - {X^T}y - {X^T}y + 2\lambda w\\
\;\;\;\;\;\;\;\; = 2\left( {{X^T}X + \lambda I} \right)w - 2{X^T}y\\
\;\;\;\;\;\;\;\; = 0\\
\therefore w = {\left( {{X^T}X + \lambda I} \right)^{ - 1}}{X^T}y
\end{array}</script><p>我们<strong>假设当前的权重W和输出y都是一维向量</strong>，则矩阵的求导公式满足:</p><script type="math/tex;mode=display">\begin{array}{l}
\frac{{d\left( {XA} \right)}}{{dX}} = A,\frac{{d\left( {AX} \right)}}{{dX}} = {A^T},\frac{{d\left( {{X^T}A} \right)}}{{dX}} = A,\frac{{d\left( {{X^T}AX} \right)}}{{dX}} = \left( {A + {A^T}} \right)X,\\
\frac{{d\left( {{A^T}XB} \right)}}{{dX}} = A{B^T},\frac{{d\left( {{A^T}{X^T}B} \right)}}{{dX}} = B{A^T},\frac{{d\left( {{A^T}{X^T}XA} \right)}}{{dX}} = 2XA{A^T}
\end{array}</script><p>不过，由于后面要引入复频域空间，所以我们这里做一些微调:</p><script type="math/tex;mode=display">w = {\left( {{X^H}X + \lambda I} \right)^{ - 1}}{X^H}y\tag{1-2}</script><p>其中，H 代表共轭转置，即在转置的同时将矩阵内所有元素变为其共轭形式，原因很简单：</p><script type="math/tex;mode=display">\left( {a + bi} \right)\left( {a - bi} \right) = {a^2} + {b^2}\tag{1-3}</script><h2 id="2-循环矩阵"><a href="#2-循环矩阵" class="headerlink" title="2. 循环矩阵"></a>2. 循环矩阵</h2><h3 id="2-1-循环矩阵的引入"><a href="#2-1-循环矩阵的引入" class="headerlink" title="2.1 循环矩阵的引入"></a>2.1 循环矩阵的引入</h3><p>由于在目标跟踪中定位目标时如果采用循环移位的方式定位其中心，则需要采用循环的方式逐步判断，这样做太耗时，因此作者引入了循环矩阵。这样做的话，我们的待选目标框不用移动，直接将原图像矩阵循环移位。以一维矩阵为例：</p><script type="math/tex;mode=display">K = \left[ {\begin{array}{*{20}{c}}
0&1&0& \ldots &0\\
0&0&1& \ldots &0\\
0&0& \ldots &1&0\\
 \vdots & \vdots & \vdots & \ddots & \vdots \\
1&0&0& \ldots &0
\end{array}} \right]\tag{2-1}</script><p>矩阵的每一行相对上一行都向右移动了一位，这里举这个矩阵例子是有用意的，通过该矩阵的n阶形式，我们可以轻松的实现任意矩阵 <em>X</em> 的右移$XK^T$或者下移$KX$ ，如：</p><script type="math/tex;mode=display">X = C\left( x \right) = \left[ {\begin{array}{*{20}{c}}
{{x_1}}&{{x_2}}& \ldots &{{x_n}}\\
{{x_n}}&{{x_1}}& \ldots &{{x_{n - 1}}}\\
 \vdots & \vdots & \ddots & \vdots \\
{{x_2}}&{{x_3}}& \ldots &{{x_1}}
\end{array}} \right]\tag{2-2}</script><p><img src="https://blogdata-1258545379.cos.ap-shanghai.myqcloud.com/20190201/1549029068783.png" alt="1549029068783"></p><h3 id="2-2-循环矩阵的转换"><a href="#2-2-循环矩阵的转换" class="headerlink" title="2.2 循环矩阵的转换"></a>2.2 循环矩阵的转换</h3><p>循环矩阵本身是将循环移位的结果整合到了一个矩阵中，虽然可以将循环计算过程优化为矩阵运算，但对于图像这类二维矩阵，则会生成一个很大的循环矩阵，从而耗费内存。这里作者巧妙地引入了离散傅里叶变换(DFT)，将循环矩阵X等价为：</p><script type="math/tex;mode=display">X = Fdiag\left( {\mathord{\buildrel{\lower3pt\hbox{$\scriptscriptstyle\frown$}} 
\over x} } \right){F^H}\tag{2-3}</script><p>其中 <em>F</em> 与离散傅里叶变换中的矩阵有所差异，${\mathord{\buildrel{\lower3pt\hbox{$\scriptscriptstyle\frown$}}<br>\over x} }​$就是原矩阵的傅里叶变换，<em>diag</em>是将矩阵变为对角形式，后面会详细解释。</p><p>先以一维矩阵为例来证明：</p><ul><li><p><strong>Step1</strong> 定义循环矩阵 <em>X</em> 的多项式函数为：</p><script type="math/tex;mode=display">X = {f_X}\left( K \right) = {x_0}I + {x_1}K + {x_2}{K^2} + ... + {x_{n - 1}}{K^{n - 1}}\tag{2-4}</script><p>这里先说明一下，单位矩阵 <em>I</em> 其实也是一个循环矩阵，而 $P^n $其实就是将矩阵<em>I</em>所有元素右移 <em>n</em> 个单位。</p></li><li><p><strong>Step2</strong> 求矩阵<em>K</em>的特征值和特征向量：</p><script type="math/tex;mode=display">\begin{array}{l}
	\because \left| {\lambda I - K} \right| = \left| {\begin{array}{*{20}{c}}
	\lambda &{ - 1}& \ldots &0\\
	0&\lambda & \ldots &0\\
	 \vdots & \vdots & \ddots & \vdots \\
	{ - 1}&0& \cdots &\lambda 
	\end{array}} \right| = {\lambda ^n} + {\left( { - 1} \right)^{n + 1}} \times {\left( { - 1} \right)^n} = {\lambda ^n} - 1\\
	\therefore {\lambda _k} = \cos \frac{{2\pi k}}{n} + i\sin \frac{{2\pi k}}{n} = {e^{\frac{{2\pi k}}{n}}},0 \le k \le n - 1\\
	\because \left[ {\begin{array}{*{20}{c}}
	{{\lambda _k}}&{ - 1}& \ldots &0\\
	0&{{\lambda _k}}& \ldots &0\\
	 \vdots & \vdots & \ddots & \vdots \\
	{ - 1}&0& \cdots &{{\lambda _k}}
	\end{array}} \right]\left[ {\begin{array}{*{20}{c}}
	{{x_1}}\\
	{{x_2}}\\
	 \vdots \\
	{{x_n}}
	\end{array}} \right] = 0\\
	\therefore {\lambda _k} = \frac{{{x_1}}}{{{x_0}}} = \frac{{{x_2}}}{{{x_1}}} = ... = \frac{{{x_n}}}{{{x_{n - 1}}}}\\
	\therefore {x_n} = \lambda _k^{n - 1}{x_0}\\
	\therefore {D_k} = {\left[ {\begin{array}{*{20}{c}}
	{\lambda _k^0}&{\lambda _k^1}& \cdots &{\lambda _k^{n - 1}}
	\end{array}} \right]^T} = {\left[ {\begin{array}{*{20}{c}}
	{{e^0}}&{{e^{\frac{{2\pi k}}{n}}}}& \cdots &{{e^{\frac{{2\pi k\left( {n - 1} \right)}}{n}}}}
	\end{array}} \right]^T}\\
	\therefore 基础解系为： {D} = \left[ {\begin{array}{*{20}{c}}
	{{e^0}}&{{e^0}}& \cdots &{{e^0}}\\
	{{e^0}}&{{e^{\frac{{2\pi }}{n}}}}& \cdots &{{e^{\frac{{2\pi \left( {n - 1} \right)}}{n}}}}\\
	 \vdots & \vdots & \ddots & \vdots \\
	{{e^0}}&{{e^{\frac{{2\pi \left( {n - 1} \right)}}{n}}}}& \cdots &{{e^{\frac{{2\pi {{\left( {n - 1} \right)}^2}}}{n}}}}
	\end{array}} \right]
	\end{array}</script><p>可以发现矩阵 <em>K</em> 的特征矩阵与 <em>DFT</em> 的变换矩阵 <em>W</em> 一致，再利用多项式矩阵的性质可知,循环矩阵 <em>X</em> 的特征值为${f_X}\left( {diag\left( {{\lambda _k}} \right)} \right)​$, 利用矩阵与其特征值矩阵相似的特点, 可以很容易的证明该性质。</p></li><li><p><strong>Step3</strong> 求循环矩阵 <em>X</em> 的特征值和特征向量：</p><script type="math/tex;mode=display">\begin{array}{l}
	\because diag\left( {{\lambda _x}} \right)\\
	 = {f_X}\left( {diag\left( {{\lambda _k}} \right)} \right)\\
	 = {x_0} + {x_1}\left[ {\begin{array}{*{20}{c}}
	{{e^0}}&0& \cdots &0\\
	0&{{e^{\frac{{2\pi }}{n}}}}& \cdots &0\\
	 \vdots & \vdots & \ddots & \vdots \\
	0&0& \cdots &{{e^{\frac{{2\pi \left( {n - 1} \right)}}{n}}}}
	\end{array}} \right] + ... + {x_{n - 1}}\left[ {\begin{array}{*{20}{c}}
	{{e^0}}&0& \cdots &0\\
	0&{{e^{\frac{{2\pi \left( {n - 1} \right)}}{n}}}}& \cdots &0\\
	 \vdots & \vdots & \ddots & \vdots \\
	0&0& \cdots &{{e^{\frac{{2\pi {{\left( {n - 1} \right)}^2}}}{n}}}}
	\end{array}} \right]\\
	 = \left[ {\begin{array}{*{20}{c}}
	{\sum\limits_{i = 0}^{n - 1} {{e^{\frac{{2\pi 0}}{n}i}}{x_i}} }&0& \cdots &0\\
	0&{\sum\limits_{i = 0}^{n - 1} {{e^{\frac{{2\pi 1}}{n}i}}{x_i}} }& \cdots &0\\
	 \vdots & \vdots & \ddots & \vdots \\
	0&0& \cdots &{\sum\limits_{i = 0}^{n - 1} {{e^{\frac{{2\pi \left( {n - 1} \right)}}{n}i}}{x_i}} }
	\end{array}} \right]\\
	\therefore {\lambda _x} = \left[ {\begin{array}{*{20}{c}}
	{{e^0}}&{{e^0}}& \cdots &{{e^0}}\\
	{{e^0}}&{{e^{\frac{{2\pi }}{n}}}}& \cdots &{{e^{\frac{{2\pi \left( {n - 1} \right)}}{n}}}}\\
	 \vdots & \vdots & \ddots & \vdots \\
	{{e^0}}&{{e^{\frac{{2\pi \left( {n - 1} \right)}}{n}}}}& \cdots &{{e^{\frac{{2\pi {{\left( {n - 1} \right)}^2}}}{n}}}}
	\end{array}} \right]\left[ {\begin{array}{*{20}{c}}
	{{x_0}}\\
	{{x_1}}\\
	 \vdots \\
	{{x_{n - 1}}}
	\end{array}} \right] = Dx
	\end{array}</script><p>可以发现循环矩阵 <em>X</em> 的特征值就是其原矩阵 <em>x</em> 的离散傅里叶变换，对于循环矩阵的特征向量，推导过程如下:</p><script type="math/tex;mode=display">\begin{array}{l}
	\because {K^{n - 1}}{D_k} = {\lambda _k}{K^{n - 2}}{D_k} = ... = {\lambda _k}^{n - 1}{D_k}\\
	\therefore {K^{n - 1}}的特征值是{\lambda _k}^{n - 1}，而特征向量不变\\
	\therefore X的特征向量同样是{D_k}
	\end{array}</script><p>在这里我们将 $D_k $替换为 <em>DFT</em> 变换矩阵<em>W</em> ，利用矩阵对角化可知：</p><script type="math/tex;mode=display">X = Wdiag\left( {{\lambda _x}} \right){W^{ - 1}} = Wdiag\left( {Wx} \right){W^{ - 1}} = Wdiag\left( {\mathord{\buildrel{\lower3pt\hbox{$\scriptscriptstyle\frown$}} 
	\over x} } \right){W^{ - 1}}\tag{2-5}</script></li><li><p><strong>Step4</strong> 利用 <em>DFT</em> 变换矩阵 <em>W</em> 的性质修正 <em>X</em> :</p><p>通过观察可知 <em>W</em> 为对称矩阵，另外也可以轻松证明${W^H}W = W{W^H} = nI​$，在这里呢，我们可以对 <em>W</em> 进行适当地变换：</p><script type="math/tex;mode=display">F = \frac{1}{{\sqrt n }}W\tag{2-6}</script><p>因此${F^H}F = F{F^H} = I​$，则 <em>F</em> 为酉矩阵，同时它也满足 ${F^H} = {F^{-1}}​$，如果我们将之前的 <em>W</em> 替换为 <em>F</em> ，那么：</p><script type="math/tex;mode=display">X = \frac{1}{{\sqrt n }}Wdiag\left( {\mathord{\buildrel{\lower3pt\hbox{$\scriptscriptstyle\frown$}} 
	\over x} } \right)\sqrt n {W^{ - 1}} = X\tag{2-7}</script><p>所以整体来看， <em>X</em> 保持不变，综上可得公式(2-3)。</p></li></ul><h3 id="2-3-二维循环矩阵"><a href="#2-3-二维循环矩阵" class="headerlink" title="2.3 二维循环矩阵"></a>2.3 二维循环矩阵</h3><p>上述推导都是基于一维矩阵进行的，那么对于二维矩阵的循环矩阵则是要进行两次一维的循环矩阵变换，下面简要介绍一下方法，完整的我不会推导~</p><p><img src="https://blogdata-1258545379.cos.ap-shanghai.myqcloud.com/20190201/1549042686678.png" alt="1549042686678"></p><p>对于 <em>m×n</em> 的矩阵 <em>x</em>，其循环矩阵是将其当作块矩阵，矩阵每一行的元素都是前一个元素向下平移得来的，每一列都是向右平移得来的。因此其循环矩阵大小为 <em>mn×mn</em>，这主要是为了将循环矩阵 <em>X</em> 变为方阵，这样才能求其特征值和特征向量。当然，如果原矩阵 <em>x</em> 本身就是方阵，那么则不必这样做，可以将行向量改为右移，列向量改为下移，这样就符合观察习惯，这也是论文代码所采用的方式。</p><p>先将 <em>n×n</em> 大小的矩阵 <em>x</em> 每一行向量单独看作一个 <em>1×n</em> 的块矩阵，按照一维循环矩阵$Kx​$的逻辑去做，不断下移，可得一个 $n^2×n​$的块矩阵。然后再将每一列向量单独看作一个$ n^2×1​$ 的块矩阵,按照 $xK^T​$的方式，不断右移，最后可得一个 ${n^2} × {n^2}​$的块矩阵。其中二维的 DFT 变换方式为 $WXW^H​$ 。</p><h2 id="3-循环矩阵与岭回归算法的结合"><a href="#3-循环矩阵与岭回归算法的结合" class="headerlink" title="3. 循环矩阵与岭回归算法的结合"></a>3. 循环矩阵与岭回归算法的结合</h2><p>建立了循环矩阵 X 之后，如果判定其第(i, j)处的块矩阵处响应最大，即目标框相对前一个目标框向下偏移 i-1 个单位, 向右偏移 j-1 个单位。那么标签 y的大小也就是 n×n。将其与岭回归算法结合之后可以得到:</p><script type="math/tex;mode=display">\begin{array}{l}
w = {\left( {{X^H}X + \lambda I} \right)^{ - 1}}{X^H}y\\
\;\;\; = {\left( {Fdiag\left( {{{\mathord{\buildrel{\lower3pt\hbox{$\scriptscriptstyle\frown$}} 
\over x} }^*}} \right){F^H} \cdot Fdiag\left( {\mathord{\buildrel{\lower3pt\hbox{$\scriptscriptstyle\frown$}} 
\over x} } \right){F^H} + \lambda Fdiag\left( \delta  \right){F^H}} \right)^{ - 1}}{X^H}y\\
\;\;\; = Fdiag\left( {\frac{1}{{{{\mathord{\buildrel{\lower3pt\hbox{$\scriptscriptstyle\frown$}} 
\over x} }^*} \odot \mathord{\buildrel{\lower3pt\hbox{$\scriptscriptstyle\frown$}} 
\over x}  + \lambda \delta }}} \right){F^H}Fdiag\left( {{{\mathord{\buildrel{\lower3pt\hbox{$\scriptscriptstyle\frown$}} 
\over x} }^*}} \right){F^H}y\\
\;\;\; = Fdiag\left( {\frac{{{{\mathord{\buildrel{\lower3pt\hbox{$\scriptscriptstyle\frown$}} 
\over x} }^*}}}{{{{\mathord{\buildrel{\lower3pt\hbox{$\scriptscriptstyle\frown$}} 
\over x} }^*} \odot \mathord{\buildrel{\lower3pt\hbox{$\scriptscriptstyle\frown$}} 
\over x}  + \lambda \delta }}} \right){F^H}y
\end{array}</script><p>其中，${{{\mathord{\buildrel{\lower3pt\hbox{$\scriptscriptstyle\frown$}} \over x} }^*}}$表示 <em>x</em> 经 DFT 变换之后的共轭形式，$\delta $表示全 1 向量，其等同于单位矩阵的特征向量，$\odot $表示矩阵元素点乘。</p><p>根据DFT时域卷积的性质：</p><script type="math/tex;mode=display">x\left( n \right) \otimes y\left( n \right) \leftrightarrow F\left( x \right)F\left( y \right)\tag{3-1}</script><p>而时域卷积常用的是循环卷积，即将原序列看作一个周期，通过验证可以得到：</p><script type="math/tex;mode=display">x\left( n \right) \otimes y\left( n \right) = C{\left( x \right)^T}y\tag{3-2}</script><p>可以发现${X^H} = C{\left( x \right)^H} = Fdiag\left( {{{\mathord{\buildrel{\lower3pt\hbox{$\scriptscriptstyle\frown$}} \over x} }^*}} \right){F^H}​$,因此可得：</p><script type="math/tex;mode=display">F\left( {C{{\left( x \right)}^T}y} \right) = \mathord{\buildrel{\lower3pt\hbox{$\scriptscriptstyle\frown$}} 
\over x}  \odot \mathord{\buildrel{\lower3pt\hbox{$\scriptscriptstyle\frown$}} 
\over y} \tag{3-3}</script><p>利用上面的结论可以继续转换w为：</p><script type="math/tex;mode=display">Fw = \mathord{\buildrel{\lower3pt\hbox{$\scriptscriptstyle\frown$}} 
\over w}  = F{F^H}{\left( {\frac{{{{\mathord{\buildrel{\lower3pt\hbox{$\scriptscriptstyle\frown$}} 
\over x} }^*}}}{{{{\mathord{\buildrel{\lower3pt\hbox{$\scriptscriptstyle\frown$}} 
\over x} }^*} \odot \mathord{\buildrel{\lower3pt\hbox{$\scriptscriptstyle\frown$}} 
\over x}  + \lambda \delta }}} \right)^*} \odot Fy = \frac{{\mathord{\buildrel{\lower3pt\hbox{$\scriptscriptstyle\frown$}} 
\over x}  \odot \mathord{\buildrel{\lower3pt\hbox{$\scriptscriptstyle\frown$}} 
\over y} }}{{{{\mathord{\buildrel{\lower3pt\hbox{$\scriptscriptstyle\frown$}} 
\over x} }^*} \odot \mathord{\buildrel{\lower3pt\hbox{$\scriptscriptstyle\frown$}} 
\over x}  + \lambda \delta }}\tag{3-4}</script><p>至此，权重矩阵 w 的求解在傅式空间变成了简单的点乘运算，运算复杂度大幅降低。</p><h2 id="4-对偶空间的引入"><a href="#4-对偶空间的引入" class="headerlink" title="4. 对偶空间的引入"></a>4. 对偶空间的引入</h2><p>对偶空间的具体意义我只有一个模糊的概念，之前在运筹学中学习的时候就感觉对偶空间像是从另外一个角度分析优化问题，比方说岭回归中的权值矩阵w，它的目的是完成 X 到 y 的映射，如果将循环矩阵拉伸为多个行向量，即$n^2$个 n×n 的样本，则更直接一点就是完成从$ n^2$维空间到 1 维空间的维度转换。那么对偶空间呢？对偶空间所要考虑的就是那 $n^2$ 个样本对于问题的影响，而这个影响因子，在优化问题中常常作为约束惩罚项的系数，然后分别权衡约束对于各个样本的影响。</p><h3 id="4-1-优化角度分析"><a href="#4-1-优化角度分析" class="headerlink" title="4.1 优化角度分析"></a>4.1 优化角度分析</h3><p>原优化问题为：</p><script type="math/tex;mode=display">\mathop {\min }\limits_w {\sum\limits_{i = 1}^n {\left( {{y_i} - \sum\limits_{j = 1}^p {{x_{ij}}{w_j}} } \right)} ^2} + \lambda \sum\limits_{j = 1}^p {w_j^2} \tag{4-1}</script><p>其等价为：</p><script type="math/tex;mode=display">\begin{array}{l}
\mathop {\min }\limits_w \sum\limits_{i = 1}^n {{\xi _i}^2}  + \lambda \sum\limits_{j = 1}^p {w_j^2} \\
s.t.\;\;{y_i} - \sum\limits_{j = 1}^p {{x_{ij}}{w_j}}  = {\xi _i}
\end{array}\tag{4-2}</script><p>采用惩罚函数的方式是：</p><script type="math/tex;mode=display">\mathop {\min }\limits_w \sum\limits_{i = 1}^n {{\xi _i}^2}  + \lambda \sum\limits_{j = 1}^p {w_j^2}  + \sum\limits_{i = 1}^n {{\alpha _i}\left( {{y_i} - \sum\limits_{j = 1}^p {{x_{ij}}{w_j}}  - {\xi _i}} \right)} \tag{4-3}</script><p>可以发现，如果将${\xi _i}$ 看作${w_j}$经过一定线性变换之后在对偶空间的表现形式，则这里将其看作一个单独的变量，利用拉格朗日乘子法可得：</p><script type="math/tex;mode=display">\left\{ \begin{array}{l}
\frac{{\partial L}}{{\partial {w_j}}} = 2\lambda {w_j} - \sum\limits_{i = 1}^n {{\alpha _i}{x_{ij}}}  = 0 \Rightarrow {w_j} = \frac{1}{{2\lambda }}\sum\limits_{i = 1}^n {{\alpha _i}{x_{ij}}} \\
\frac{{\partial L}}{{\partial {\xi _i}}} = 2{\xi _i} - {\alpha _i} = 0 \Rightarrow {\xi _i} = \frac{1}{2}{\alpha _i}
\end{array} \right.\tag{4-4}</script><p>将其带入原目标函数可得：</p><script type="math/tex;mode=display">\begin{array}{l}
\mathop {\min }\limits_\alpha  \frac{1}{4}\sum\limits_{i = 1}^n {{\alpha _i}^2}  + \frac{1}{{4\lambda }}\sum\limits_{j = 1}^p {\left( {\sum\limits_{i = 1}^n {{\alpha _i}{x_{ij}}} } \right)\left( {\sum\limits_{k = 1}^n {{\alpha _k}{x_{kj}}} } \right)}  + \sum\limits_{i = 1}^n {{\alpha _i}\left( {{y_i} - \sum\limits_{j = 1}^p {{x_{ij}}\frac{1}{{2\lambda }}\sum\limits_{k = 1}^n {{\alpha _k}{x_{kj}}}  - \frac{{{\alpha _i}}}{2}} } \right)} \\
 \Leftrightarrow \mathop {\min }\limits_\alpha  \sum\limits_{i = 1}^n {{\alpha _i}{y_i}}  - \frac{1}{4}\sum\limits_{i = 1}^n {{\alpha _i}^2}  - \frac{1}{{4\lambda }}\sum\limits_{i = 1}^n {\sum\limits_{k = 1}^n {{\alpha _i}{\alpha _k}} } \sum\limits_{j = 1}^p {{x_{ij}}{x_{kj}}} 
\end{array}</script><p>由此可得原优化问题的对偶问题，将其转换成矩阵形式为：</p><script type="math/tex;mode=display">\mathop {\min }\limits_\alpha  {\alpha ^T}y - \frac{1}{4}{\alpha ^T}\alpha  - \frac{1}{{4\lambda }}{\alpha ^T}G\alpha \tag{4-5}</script><p>其中 G 表示$\left\langle {{x_i},{x_j}} \right\rangle = {x_{i \cdot }}^T{x_{k \cdot }}​$，利用拉格朗日乘子法可得：</p><script type="math/tex;mode=display">\frac{{\partial Q}}{{\partial \alpha }} = y - \frac{1}{2}\alpha  - \frac{1}{{2\lambda }}G\alpha  \Rightarrow \alpha  = 2\lambda {\left( {G + \lambda I} \right)^{ - 1}}y\tag{4-6}</script><p>再将此对偶空间的最优解带入公式（4-4）可得：</p><script type="math/tex;mode=display">w = \frac{1}{{2\lambda }}{X^T}\alpha  = {X^T}{\left( {G + \lambda I} \right)^{ - 1}}y\tag{4-7}</script><h3 id="4-2-矩阵变换角度"><a href="#4-2-矩阵变换角度" class="headerlink" title="4.2 矩阵变换角度"></a>4.2 矩阵变换角度</h3><p>上面的优化方法更侧重于从理论源头出发，而如果真的要用的话，可以直接用上面的理论，因此呢我们可以直接对矩阵进行变换：</p><script type="math/tex;mode=display">\begin{array}{l}
\because\left( {{X^T}X + \lambda I} \right)w = {X^T}y\\
\therefore w = {\lambda ^{ - 1}}\left( {{X^T}y - {X^T}Xw} \right) = {\lambda ^{ - 1}}{X^T}\left( {y - Xw} \right) - {X^T}\alpha \\
\therefore \alpha  = {\lambda ^{ - 1}}\left( {y - Xw} \right)\\
\therefore \lambda \alpha  = y - X{X^T}\alpha \\
\therefore \alpha  = {\left( {{X^T}X + \lambda I} \right)^{ - 1}}y = {\left( {G + \lambda I} \right)^{ - 1}}y
\end{array}</script><h3 id="4-3-新样本测试"><a href="#4-3-新样本测试" class="headerlink" title="4.3 新样本测试"></a>4.3 新样本测试</h3><p>训练好参数之后，当引入新样本时，可以直接利用 <em>wx</em> 的方式求出响应 y,根据公式（4-7）可得：</p><script type="math/tex;mode=display">f\left( z \right) = Z{X^T}{\left( {G + \lambda I} \right)^{ - 1}}y = {y^T}{\left( {G + \lambda I} \right)^{ - 1}}X{Z^T} = {y^T}{\left( {{G_{xx}} + \lambda I} \right)^{ - 1}}{G_{xz}}\tag{4-8}</script><h2 id="5-核函数的高维映射"><a href="#5-核函数的高维映射" class="headerlink" title="5.核函数的高维映射"></a>5.核函数的高维映射</h2><h3 id="5-1核函数的引入"><a href="#5-1核函数的引入" class="headerlink" title="5.1核函数的引入"></a>5.1核函数的引入</h3><p>核函数的引入主要是为了减少线性不可分问题的影响，因为岭回归跟神经网络或者深度学习不同，它是单层结构，需要从空间映射来着手。<br>常见的核函数有线性函数、多项式核函数和高斯核函数（RBF），而论文中则是采用了 RBF 核函数，理论上来讲是映射到了无穷维数的空间，可以通过展开其级数得知。</p><p><img src="https://blogdata-1258545379.cos.ap-shanghai.myqcloud.com/20190201/1549204757681.png" alt="1549204757681"></p><p>如图所示，黑色和蓝色区域明显是一个线性不可分的，而利用一个二次函数却能完美分割，这就是核函数的意义。本文所使用的核函数是高斯核函数：</p><script type="math/tex;mode=display">K = {e^{ - \frac{{{{\left( {x - \mu } \right)}^2}}}{{2{\sigma ^2}}}}}\tag{5-1}</script><p>论文中将核函数引入样本的点积，即：</p><script type="math/tex;mode=display">f\left( z \right) = {y^T}{\left( {{K^{xx}} + \lambda I} \right)^{ - 1}}{K^{xz}} = {\alpha ^T}{K^{xz}}\tag{5-2}</script><h3 id="5-2-核函数与循环矩阵的结合"><a href="#5-2-核函数与循环矩阵的结合" class="headerlink" title="5.2 核函数与循环矩阵的结合"></a>5.2 核函数与循环矩阵的结合</h3><p>对于任何的循环矩阵 X，还是以一维的原矩阵 x 为例，可知：</p><script type="math/tex;mode=display">K_{ij}^{xx} = K\left( {{P^i}x,{P^j}x} \right) = K\left( {{P^{ - i}}{P^i}x,{P^{ - i}}{P^j}x} \right) = K\left( {x,{P^{j - i}}x} \right) = K\left( {x,{P^{\left( {j - i} \right)\;\bmod \;n}}x} \right)\tag{5-3}</script><p>其中由于 P 是循环矩阵的基础变换矩阵，也就是前面所提到的 K 矩阵，这里是为了与核函数区分开来，在矩阵点积中，两个矩阵的元素对应相乘，因此两个矩阵同时移位$ P^i​$，并不会影响结果。<br>由公式（5-3）可知，只要行号和列号的差值相同，其对应元素的值就相同，所以 $K^{xx}​$是循环矩阵。再利用循环矩阵的特性（2-3）可得：</p><script type="math/tex;mode=display">\begin{array}{l}
\because \alpha  = {\left( {{K^{xx}} + \lambda I} \right)^{ - 1}}y\\
\;\;\;\;\;\; = {\left( {Fdiag\left( {{{\mathord{\buildrel{\lower3pt\hbox{$\scriptscriptstyle\frown$}} 
\over k} }^{xx}}} \right){F^H} + \lambda I} \right)^{ - 1}}y\\
\;\;\;\;\;\; = Fdiag\left( {\frac{1}{{{{\mathord{\buildrel{\lower3pt\hbox{$\scriptscriptstyle\frown$}} 
\over k} }^{xx}} + \lambda }}} \right){F^H}y\\
\therefore F\alpha  = F{F^H}{\left( {\frac{1}{{{{\mathord{\buildrel{\lower3pt\hbox{$\scriptscriptstyle\frown$}} 
\over k} }^{xx}} + \lambda }}} \right)^*} \odot Fy\\
\therefore \mathord{\buildrel{\lower3pt\hbox{$\scriptscriptstyle\frown$}} 
\over \alpha }  = \frac{{\mathord{\buildrel{\lower3pt\hbox{$\scriptscriptstyle\frown$}} 
\over y} }}{{{{\mathord{\buildrel{\lower3pt\hbox{$\scriptscriptstyle\frown$}} 
\over k} }^{x{x^*}}} + \lambda }}\\
\because k_i^{xx} = K\left( {{x_0},{x_i}} \right),k_{n - i}^{xx} = K\left( {{x_0},{x_{n - i}}} \right) = K\left( {{x_0},{x_i}} \right)\\
\therefore {{\mathord{\buildrel{\lower3pt\hbox{$\scriptscriptstyle\frown$}} 
\over k} }^{x{x^*}}} = {{\mathord{\buildrel{\lower3pt\hbox{$\scriptscriptstyle\frown$}} 
\over k} }^{xx}}\\
\therefore \mathord{\buildrel{\lower3pt\hbox{$\scriptscriptstyle\frown$}} 
\over \alpha }  = \frac{{\mathord{\buildrel{\lower3pt\hbox{$\scriptscriptstyle\frown$}} 
\over y} }}{{{{\mathord{\buildrel{\lower3pt\hbox{$\scriptscriptstyle\frown$}} 
\over k} }^{xx}} + \lambda }}
\end{array}</script><p>同理可得：</p><script type="math/tex;mode=display">\mathord{\buildrel{\lower3pt\hbox{$\scriptscriptstyle\frown$}} 
\over f} \left( z \right) = {\mathord{\buildrel{\lower3pt\hbox{$\scriptscriptstyle\frown$}} 
\over k} ^{xz}} \odot \mathord{\buildrel{\lower3pt\hbox{$\scriptscriptstyle\frown$}} 
\over \alpha } \tag{5-4}</script><blockquote><p>虽然原论文关于w的推导错误了，但是代码是根据$\alpha $来实现的，所以正确。</p></blockquote><h3 id="5-3-不同核函数的计算"><a href="#5-3-不同核函数的计算" class="headerlink" title="5.3 不同核函数的计算"></a>5.3 不同核函数的计算</h3><p>从最基础的内积出发，其核函数形式就是：</p><script type="math/tex;mode=display">{K^{xz}} = {X^T}z = C\left( x \right){z^T} = {F^{ - 1}}{\left( {{{\mathord{\buildrel{\lower3pt\hbox{$\scriptscriptstyle\frown$}} 
\over x} }^*} \odot \mathord{\buildrel{\lower3pt\hbox{$\scriptscriptstyle\frown$}} 
\over z} } \right)^T}\tag{5-5}</script><p>对于多项式核，则有：</p><script type="math/tex;mode=display">{K^{xz}} = {\left( {{X^T}z + a} \right)^b} = \left[ {{F^{ - 1}}{{\left( {{{\mathord{\buildrel{\lower3pt\hbox{$\scriptscriptstyle\frown$}} 
\over x} }^*} \odot \mathord{\buildrel{\lower3pt\hbox{$\scriptscriptstyle\frown$}} 
\over z} } \right)}^T} + a} \right]\tag{5-6}</script><p>对于 RBF 径向基核，也就是常说的高斯核函数，有：</p><script type="math/tex;mode=display">\begin{array}{l}
\because k_i^{xz} = h\left( {{{\left\| {{x_i} - z} \right\|}^2}} \right) = h\left( {{{\left\| {{x_i}} \right\|}^2} + {{\left\| z \right\|}^2} - 2x_i^Tz} \right)\\
\therefore {k^{xz}} = h\left( {{{\left\| x \right\|}^2} + {{\left\| z \right\|}^2} - 2{X^T}z} \right)\\
\;\;\;\;\;\;\;\; = h\left( {{{\left\| x \right\|}^2} + {{\left\| z \right\|}^2} - 2{F^{ - 1}}\left( {{{\mathord{\buildrel{\lower3pt\hbox{$\scriptscriptstyle\frown$}} 
\over x} }^*} \odot \mathord{\buildrel{\lower3pt\hbox{$\scriptscriptstyle\frown$}} 
\over z} } \right)} \right)\\
\;\;\;\;\;\;\;\; = {e^{ - \frac{{{{\left\| x \right\|}^2} + {{\left\| z \right\|}^2} - 2{F^{ - 1}}\left( {{{\mathord{\buildrel{\lower3pt\hbox{$\scriptscriptstyle\frown$}} 
\over x} }^*} \odot \mathord{\buildrel{\lower3pt\hbox{$\scriptscriptstyle\frown$}} 
\over z} } \right)}}{{{\sigma ^2}}}}}
\end{array}</script><h2 id="6-模板图像的获取"><a href="#6-模板图像的获取" class="headerlink" title="6. 模板图像的获取"></a>6. 模板图像的获取</h2><p>模板图像是基于第一帧图像目标框所得到的，其具体获取过程如下：</p><ul><li><p>Step1 保持初始目标框中心不变，将目标框的宽和高同时扩大相同倍数（论文中取 2.5 倍）；</p></li><li><p>Step2 设定模板图像尺寸为 96，计算扩展框与模板图像尺寸的比例：</p><script type="math/tex;mode=display">scal{e_z} = \frac{{max\left( {w,h} \right)}}{{template}}\tag{6-1}</script></li><li><p>Step3 然后将 scale 同时应用于宽和高，获取图像提取区域：</p><script type="math/tex;mode=display">ro{i_{w,h}} = \left( {\frac{w}{{scal{e_z}}},\frac{h}{{scal{e_z}}}} \right)\tag{6-2}</script></li><li><p>Step4 由于后面提取 hog 特征时会以 cell 单元的形式提取，另外由于需要将频域直流分量移动到图像中心，因此需保证图像大小为 cell大小的偶数倍，另外，在 hog 特征的降维的过程中是忽略边界 cell 的，所以还要再加上两倍的 cell 大小：</p><p><img src="https://blogdata-1258545379.cos.ap-shanghai.myqcloud.com/20190201/1549265609508.png" alt="1549265609508"></p><script type="math/tex;mode=display">ro{i_{w,h}} = {\left[ {\frac{{ro{i_{w,h}}}}{{2cell\_size}}} \right]_{floor}} \cdot 2cell\_size + 2cell\_size\tag{6-3}</script></li><li><p>Step5 由于 roi 区域可能会超出原图像边界，因此超出边界的部分填充为原图像边界的像素；</p></li><li><p>Step6 最后利用线性插值的方式将 roi 区域采样为 template 大小。</p></li></ul><h2 id="7-特征提取"><a href="#7-特征提取" class="headerlink" title="7.特征提取"></a>7.特征提取</h2><h3 id="7-1-f-hog特征"><a href="#7-1-f-hog特征" class="headerlink" title="7.1 f-hog特征"></a>7.1 f-hog特征</h3><p>hog 特征又叫做方向梯度直方图，顾名思义，它所描述的是图像各像素点的方向梯度它对图像几何的和光学的形变都能保持很好的不变性。而论文中所用的hog 特征与常规的不同，具体的不同和实施细节我会在下文详细介绍：</p><ul><li><p><strong>Step1 梯度幅值计算。</strong></p><p>计算模板图像 RGB 三通道每个像素点的水平梯度 <em>dx</em> 和垂直梯度 <em>dy</em>，并计算各点的梯度幅值，以最大的梯度幅值所在通道为准：</p><script type="math/tex;mode=display">a = \mathop {max}\limits_{i \in \left( {r,g,b} \right)} \left( {\sqrt {{{\left( {d{x_i}} \right)}^2} + {{\left( {d{y_i}} \right)}^2}} } \right)\tag{7-1}</script></li><li><p><strong>Step2 梯度方向判定。</strong></p><p>如果像素点最大幅值所在通道为 m，则利用该通道的水平梯度和垂直梯度计算该点的梯度方向，论文中将[0,180)分为了 9 个方向，同时还将[0,360)分为了18 个方向，具体方向归属则是利用该像素点梯度在模板方向上的投影值确定：</p><script type="math/tex;mode=display">\theta  = \mathop {max}\limits_\theta  \left( {dx\cos \theta  + dy\sin \theta } \right)\tag{7-2}</script><p>分别通过以[0,180 ) 和[0,360 )为周期将个像素点的方向投影至这两个区间，从而每个像素点都有两种方向；</p></li><li><p><strong>Step3 cell的分割。</strong></p><p>确定 cell 单元尺寸（论文中设为 4），因此，水平方向有 sizeX=24,竖直方向也有 sizeY =24 个 cell，由于在计算像素点梯度时，边界像素点的梯度都是通过镜像幅值边界像素的方式计算的，因此论文中并未考虑边界点的梯度。每个 cell中的方向梯度直方图应该有 9+18 = 27 个方向。</p></li><li><p><strong>Step4 cell 内像素点梯度幅值加权方式。</strong></p><p>论文代码中关于 cell 的方向梯度直方图的求解很特别。对于每个 cell，根据其尺寸，设计了两个离散序列，因为比较有规律，所以当做两个函数 x 和 y：</p><p><img src="https://blogdata-1258545379.cos.ap-shanghai.myqcloud.com/20190201/1549270523031.png" alt="1549270523031"></p><p>通过图像可以看到，随着 cell 内像素点横纵坐标的偏移，对应的点的 x,y 值一直在变化，且两个函数关于 0.5 对称，另外 x+y=1，利用这一特性，可以利用x 和 y 进行组合分解：</p><script type="math/tex;mode=display">1 = {\left( {x + y} \right)^2} = {x^2} + xy + yx + {y^2}\tag{7-3}</script><p>利用公式（7-3），论文代码中将每个 cell 等分为 4 部分（左上、右上、左下和右下），每一部分都是由包含该 cell 在内的相邻 4 个 cell 的同一部分加权平均得来的，其权重即为公式（7-3）所示的四个部分。具体组合方式如下（以 cell左上角部分为例）：</p><p><img src="https://blogdata-1258545379.cos.ap-shanghai.myqcloud.com/20190201/1549270624282.png" alt="1549270624282"></p><p>可以发现，cell 左上部分的加权方式是以自身为左上角，然后取相邻的其他三个 cell 的左上部分组成一个新的虚 拟 cell，再利用上图 所示的权重分布将四个cell 的左上部分进行加权平均，权重正是 $x^2​$,xy,yx,$y^2​$。同理，cell 的其他三个部分也是一样的原理，比如 cell 的右下部分，则是将该 cell 的右下部分作为虚拟 cell的右下角，然后分别取该 cell 左上，正上，正左三个方向相邻的 cell 的右下部分组成新的虚拟 cell，再进行加权平均。<br>当然，对于边界 cell，则只选取不超过边界的部分 cell 进行不完整加权。</p><ul><li><p><strong>Step5 方向梯度直方图计算。</strong></p><p>对于 cell 内每个像素点，将其梯度幅值分别以[0,180 )和[0,360 ) 两种投影区间累加至对应梯度方向直方图中，在按照上一步中提到的加权方式计算完 cell特征之后，每个 cell 保留了 9+18 个方向的梯度。</p></li><li><p><strong>Step6 相对领域归一化及截断。</strong></p><p>对于每个 cell，分别取包含其在内的相邻四个 cell，如下图所示（好丑-_-||，为了区分四个 cell 的不同，尽力了。。。）</p><p><img src="https://blogdata-1258545379.cos.ap-shanghai.myqcloud.com/20190201/1549271000831.png" alt="1549271000831"></p><p>因此有四个组合方式，每种组合方式都取该组合方式内四个 cell 的方向梯度直方图的前 9 个方向梯度的 L2 范数 val，然后用该 cell 内 27 个方向的梯度直方图除以 val，即可得到规范化之后的 hog 特征。四个组合可以得到四组 hog 特征，即 9+9+9+9+18+18+18+18=108 个方向。</p><p>可以发现边界 cell 无法得到这么多方向，因此去掉边界 cell。所以sizeX=24-2=22，sizeY=22。</p></li><li><p><strong>Step7 PCA降维。</strong></p><p>作者从大量各种分辨率的图片中收集了很多36维特征（按照之前的定义），并且在这些特征上进行了PCA分析，发现了了一个现象：<strong>由前11个主特征向量定义的线性子空间基本包含了hog特征的所有信息。</strong>并且用降维之后的特征在他们的任务（目标检测）中取得了和用36维特征一样的结果。</p><p><img src="https://blogdata-1258545379.cos.ap-shanghai.myqcloud.com/20190201/5252065-a0c76ca30c0acf6f.webp" alt="img"></p><p>如果用 $C_{ij}​$表示第 <em>i</em> 组 <em>hog</em> 特征的第 <em>j</em> 个方向，则原作者代码中的降维方式分别如下：</p><script type="math/tex;mode=display">\left\{ \begin{array}{l}
		{f_1}\left( j \right) = \frac{{\sum\limits_{i = 1}^4 {{C_{ij}}} }}{{\sqrt 4 }}\\
		{f_2}\left( i \right) = \frac{{\sum\limits_{j = 1}^{18} {{C_{ij}}} }}{{\sqrt {9 \times 2} }}
		\end{array} \right.\tag{7-4}</script><p>然后将两种降维方式得到的特征进行组合，得到 27+4=31 组特征。</p><p>原论文流程示意图如下：</p></li></ul></li></ul><p><img src="https://blogdata-1258545379.cos.ap-shanghai.myqcloud.com/20190201/20180820160426679" alt="img"></p><h3 id="7-2-CN-CN2特征"><a href="#7-2-CN-CN2特征" class="headerlink" title="7.2 CN/CN2特征"></a>7.2 CN/CN2特征</h3><p>该颜色特征将颜色空间划分为了黑、蓝、棕、灰、绿、橙、粉、紫、红、白和黄共11种，然后将其投影至10维子空间的标准正交基上，这里作者给出了32768种颜色向量组合。再利用PCA技术，采用奇异值分解方式提取其中主要的两个颜色作为最终的特征。由于CN2特征是单目标跟踪领域中很有效的一种人工特征，这里对其原理做出详细描述：</p><ul><li><p><strong>Step1</strong> 根据如下计算公式，作者给出了模板矩阵w2c（32768×10）：</p><script type="math/tex;mode=display">Index\_img = 1 + \left[ {\frac{R}{8}} \right] + 32 \times \left[ {\frac{G}{8}} \right] + {32^2} \times \left[ {\frac{B}{8}} \right]\tag{7-5}</script><p>将原图的RGB三通道数据带入其中，图中每个像素位置都能得到一个索引号，范围是1~32768，将此索引号带入w2c中，便可得到一个宽高与原图一致，通道数为10的CN矩阵<em>x_pca</em>，与此同时，将其形状重塑为（W×H）×10的二维矩阵；</p></li><li><p><strong>Step2</strong> 逐帧更新外观矩阵：</p><script type="math/tex;mode=display">z\_pca = \left( {1 - learning\_rate} \right) \times z\_pca + learning\_rate \times x\_pca\tag{7-6}</script></li><li><p><strong>Step3</strong> 开始PCA，先按列对矩阵去中心化，并计算协方差矩阵cov（10×10）：</p><script type="math/tex;mode=display">\left\{ \begin{array}{l}
	dat{a_{ij}} = z\_pc{a_{ij}} - \mathop {mean}\limits_{i \in \left[ {1,WH} \right]} (z\_pc{a_{ij}})\\
	cov = \frac{1}{{HWC - 1}} \times dat{a^T} \times data
	\end{array} \right.\tag{7-7}</script></li><li><p><strong>Step4</strong> 进行奇异值分解，由于对于任何矩阵$A \in {R^{m \times n}}$都可以利用奇异值分解为$A = UD{V^H}$, 其中$U \in {R^{m \times m}}$,$D \in {R^{m \times n}}$,$V \in {R^{n \times n}}​$,而对于矩阵<em>cov</em>，<em>U=V</em>,那么<em>AU=UD</em>,所以U的列向量是协方差矩阵的特征向量，D是协方差矩阵的特征值：</p><script type="math/tex;mode=display">[U,D,U] = svd\left( {cov} \right)\tag{7-8}</script></li><li><p><strong>Step5</strong> 取U的前2列特征向量，逆分解得到新的协方差矩阵：</p><script type="math/tex;mode=display">\left\{ \begin{array}{l}
	old\_cov = \left( {1 - cp\_rate} \right) \times old\_cov + cp\_rate \times cp\_{\mathop{\rm cov}} \\
	M = U\left( {:,1:2} \right),N = D\left( {1:2,1:2} \right)\\
	cp\_{\mathop{\rm cov}}  = M \times N \times {M^T}
	\end{array} \right.\tag{7-9}</script></li><li><p><strong>Step6</strong> 更新协方差矩阵：</p><script type="math/tex;mode=display">cov = \left( {1 - cp\_rate} \right) \times cp\_cov + cp\_rate \times {\mathop{\rm cov}} \tag{7-10}</script></li><li><p><strong>Step7</strong> 得到CN2特征：</p><script type="math/tex;mode=display">CN2 = reshape(x\_pca \times M,(H,W,2))\tag{7-11}</script><p>下图可以看见原图，灰度图以及CN2特征图的区别，因为CN特征有10个通道，这里我就不放了：</p><p><img src="https://blogdata-1258545379.cos.ap-shanghai.myqcloud.com/20190201/1549286021525.png" alt="1549286021525"></p></li></ul><h2 id="8-算法实现"><a href="#8-算法实现" class="headerlink" title="8. 算法实现"></a>8. 算法实现</h2><h3 id="8-1-多通道图像特征矩阵求解"><a href="#8-1-多通道图像特征矩阵求解" class="headerlink" title="8.1 多通道图像特征矩阵求解"></a>8.1 多通道图像特征矩阵求解</h3><p>利用上述理论推导可以求得每一帧 fhog 特征，如果将其视为多通道的话，那么就是 31 通道的图像特征矩阵，然后分别对各通道使用二维汉宁窗进行滤波，为了降低 FFT 过程带来的频谱泄露，其函数形式如下：</p><script type="math/tex;mode=display">f\left( {x,y} \right) = \frac{1}{4}\left( {1 - \cos \left( {2\pi \frac{x}{n}} \right)} \right)\left( {1 - \cos \left( {2\pi \frac{y}{n}} \right)} \right)\tag{8-1}</script><p>然后分别对各个通道求解其<script type="math/tex">\mathord{\buildrel{\lower3pt\hbox{$\scriptscriptstyle\frown$}} 
\over x}</script>，对各通道数据进行多通道处理，处理方式如下:</p><script type="math/tex;mode=display">\begin{array}{l}
{k^{xx'}} = g\left( {C\left( x \right)x'} \right)\\
\;\;\;\;\;\; = g\left( {\sum\limits_{c = 1}^{L = 31} {C\left( {{x^c}} \right)x'} } \right)\\
\;\;\;\;\;\; = g\left( {\sum\limits_{c = 1}^L {{F^{ - 1}}\left( {{{\left( {{{\mathord{\buildrel{\lower3pt\hbox{$\scriptscriptstyle\frown$}} 
\over x} }^c}} \right)}^*}{{\mathord{\buildrel{\lower3pt\hbox{$\scriptscriptstyle\frown$}} 
\over x} }^c}'} \right)} } \right)\\
\;\;\;\;\;\; = g\left( {{F^{ - 1}}\left( {\sum\limits_{c = 1}^L {{{\left( {{{\mathord{\buildrel{\lower3pt\hbox{$\scriptscriptstyle\frown$}} 
\over x} }^c}} \right)}^*}{{\mathord{\buildrel{\lower3pt\hbox{$\scriptscriptstyle\frown$}} 
\over x} }^c}'} } \right)} \right)\\
\;\;\;\;\;\; = {e^{ - \frac{{{{\left\| x \right\|}^2} + {{\left\| {x'} \right\|}^2} - 2{F^{ - 1}}\left( {\sum\limits_{c = 1}^L {{{\left( {{{\mathord{\buildrel{\lower3pt\hbox{$\scriptscriptstyle\frown$}} 
\over x} }^c}} \right)}^*}{{\mathord{\buildrel{\lower3pt\hbox{$\scriptscriptstyle\frown$}} 
\over x} }^c}'} } \right)}}{{{\sigma ^2}}}}}
\end{array}</script><h3 id="8-2-标签制作"><a href="#8-2-标签制作" class="headerlink" title="8.2 标签制作"></a>8.2 标签制作</h3><p>利用第五章所得结论，可以求得${\mathord{\buildrel{\lower3pt\hbox{$\scriptscriptstyle\frown$}}<br>\over \alpha } }$。对于 groundtruth，由于模板函数的中心就是目标框的中心，因此论文中使用高斯分布函数作为标签,其分布函数如下：</p><script type="math/tex;mode=display">\left\{ \begin{array}{l}
g\left( {x,y} \right) = {e^{ - \frac{{{{\left( {i - cx} \right)}^2} + {{\left( {j - cy} \right)}^2}}}{{2{\sigma ^2}}}}}\\
\sigma  = \frac{{\sqrt {sizeX \cdot sizeY} }}{{padding \cdot output\_\sigma }}
\end{array} \right.\tag{8-2}</script><p>其中,(cx,cy)表示图像特征矩阵中心，padding 表示扩展框相对目标框的变化比例 2.5，${output_\sigma }​$表示设定的一个值 0.125。</p><h3 id="8-3-多尺度检测"><a href="#8-3-多尺度检测" class="headerlink" title="8.3 多尺度检测"></a>8.3 多尺度检测</h3><p>论文代码中，作者设置了三种尺度，设定尺度步长为 scalestep=1.05，然后分别以 $1.05^{-1}$,$1.05^0$,$1.05^1$三种尺度 scale 进行检测，这里尺度的操作对象是第六章所提到的 roi 矩阵，即<script type="math/tex">roi_{w,h}=scale*roi_{w,h}</script>。首先，为了防止在更新过程中目标框左上角位于图像边界，从而目标框变成了一条线或者一个点，作者将这一类目标框的左上角向远离图像边界的方向移动了一个单位。</p><p>每一尺度都能求得 f(z)响应矩阵，虽然该响应矩阵对应了循环矩阵每个块矩阵的响应，但是第 i 行第 j 列的块矩阵所对应的响应，正是目标框右移 i-1 个单位，下移 j-1 个单位后的响应，即下一帧图像矩阵 z 的响应。对于该响应矩阵，找出其最大响应值 peak<em>value 和最大响应位置 $p</em>{xy}​$。<br>如果最大响应位置不在图像边界，那么分别比较最大响应位置两侧的响应大小，如果右侧比左侧高，或者下侧比上侧高，则分别将最大响应位置向较大的一侧移动一段距离：</p><script type="math/tex;mode=display">\left\{ \begin{array}{l}
{p_x} = {p_x} + 0.5\frac{{right - left}}{{2peak\_value - right - left}}\\
{p_y} = {p_y} + 0.5\frac{{down - up}}{{2peak\_value - down - up}}
\end{array} \right.\tag{8-3}</script><p>然后计算此位置与图像中心的距离 res。</p><p>对于不同的尺度，都有着尺度惩罚系数 scale_weight,用此系数乘以该尺度下的最大响应值作为该尺度下的真实最大响应值，取最大响应值对应的尺度为最佳尺度，记为 best_scale。以此来更新目标框参数 T（x,y,w,h）：</p><script type="math/tex;mode=display">\left\{ \begin{array}{l}
scal{e_z} = scal{e_z} \cdot best\_scale\\
{T_{w,h}} = {T_{w,h}} \cdot best\_scale\\
{T_{x,y}} = {T_{x,y}} - {T_{w,h}}/2 + re{s_{x,y}} \cdot cell\_size \cdot best\_scale
\end{array} \right.\tag{8-4}</script><h3 id="8-4-模板更新"><a href="#8-4-模板更新" class="headerlink" title="8.4 模板更新"></a>8.4 模板更新</h3><p>首先获取原尺度下当前帧的 fhog 特征矩阵 z，作者代码中这一部分没有用汉宁窗进行滤波，可能是考虑到更新时这一部分的权重不大，其模板和${\mathord{\buildrel{\lower3pt\hbox{$\scriptscriptstyle\frown$}}<br>\over \alpha } }​$ 的更新公式如下：</p><script type="math/tex;mode=display">\left\{ \begin{array}{l}
template = \left( {1 - 0.012} \right) \times template + 0.012z\\
\mathord{\buildrel{\lower3pt\hbox{$\scriptscriptstyle\frown$}} 
\over \alpha }  = \left( {1 - 0.012} \right) \times \mathord{\buildrel{\lower3pt\hbox{$\scriptscriptstyle\frown$}} 
\over \alpha }  + 0.012{{\mathord{\buildrel{\lower3pt\hbox{$\scriptscriptstyle\frown$}} 
\over \alpha } }_{xz}}
\end{array} \right.\tag{8-5}</script><h2 id="9-总结"><a href="#9-总结" class="headerlink" title="9.总结"></a>9.总结</h2><p>整体来讲，本文通过循环矩阵的方式将循环移位的运算复杂度降低了，然后通过引入傅里叶变换使得主要的矩阵乘法变成了点乘，再次降低了运算量。再通过引入对偶空间和核函数，增加了岭回归分类器的性能。整体来说，其算法结构比较简单，也正因如此，其跟踪速度也很快。</p><p>不过其中也暴露了很多问题:</p><ul><li>虽然模板和 ${\mathord{\buildrel{\lower3pt\hbox{$\scriptscriptstyle\frown$}}<br>\over \alpha } }$更新部分对于当前帧的权重比较小，但是其更新是针对整个矩阵进行的，所以如果出现一段遮挡的场景，此模板将一去不复返。这与 siam-fc的模板更新不同，深度网络的跟踪方式通常只是更新目标框的中心位置，以及对目标框大小的微调；</li><li>论文中使用了三个尺度，对于尺度的应用很微小，所以作用很小，在后面Martin Danelljan 所提出的改进算法 DSST 中算法效果有显著提高，不过用了33 个尺度，其对应的算法速度也就降下来了，所以该算法的核心竞争力降低了；</li><li>当目标出现形变时，效果会变得很不好，因为 KCF 的核心其实是模板匹配，目标变形时，自然也就难以匹配好；</li><li>论文中加入的汉宁窗虽然有减少 FFT 频谱泄露的作用，但是由于其分布特性，使得边缘像素cell 的值几乎为 0，因此丢失了大量信息。可能最大响应位置并非最大，甚至有可能过滤掉出现在边缘的目标；</li></ul><hr><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><p>High-Speed Tracking with Kernelized Correlation Filters, Joao F.Henriques, IEEE TRANSACTIONS ON PATTERN ANALYSIS AND MACHINE INTELLIGENCE , 2015.</p></li><li><p>Forsyth D . Object Detection with Discriminatively Trained Part-Based Models[J]. 2014.</p></li><li><p><a href="https://www.jianshu.com/p/69a3e39c51f9">https://www.jianshu.com/p/69a3e39c51f9</a></p></li><li><p><a href="https://www.cnblogs.com/torsor/p/8848641.html">https://www.cnblogs.com/torsor/p/8848641.html</a></p></li><li><p>原作者C++源码：<a href="https://github.com/joaofaro/KCFcpp">https://github.com/joaofaro/KCFcpp</a></p></li><li><p>QiangWang复现C++源码：<a href="https://github.com/foolwood/KCF">https://github.com/foolwood/KCF</a></p></li><li><p>原作者博士论文：<a href="http://www.robots.ox.ac.uk/~joao/publications/henriques_phd.pdf">http://www.robots.ox.ac.uk/~joao/publications/henriques_phd.pdf</a></p></li></ol></div><div><div><div style="text-align:center;color:#ccc;font-size:14px">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div></div></div><div><div style="padding:10px 0;margin:20px auto;width:90%;text-align:center"><div>坚持原创技术分享，您的支持将鼓励我继续创作！</div><button id="rewardButton" disable="enable" onclick='var e=document.getElementById("QR");"none"===e.style.display?e.style.display="block":e.style.display="none"'><span>打赏</span></button><div id="QR" style="display:none"><div id="wechat" style="display:inline-block"><img id="wechat_qr" src="/images/wechatpay.jpg" alt="黄飘 微信支付"><p>微信支付</p></div><div id="alipay" style="display:inline-block"><img id="alipay_qr" src="/images/alipay.jpg" alt="黄飘 支付宝"><p>支付宝</p></div></div></div></div><div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者： </strong>黄飘</li><li class="post-copyright-link"><strong>本文链接：</strong> <a href="https://huangpiao.tech/2019/02/04/剖析KCF/" title="剖析KCF">https://huangpiao.tech/2019/02/04/剖析KCF/</a></li><li class="post-copyright-license"><strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><footer class="post-footer"><div class="post-tags"><a href="/tags/目标跟踪/" rel="tag"><i class="fa fa-tag"></i> 目标跟踪</a> <a href="/tags/KCF/" rel="tag"><i class="fa fa-tag"></i> KCF</a></div><div class="post-widgets"><div class="social_share"><div id="needsharebutton-postbottom"><span class="btn"><i class="fa fa-share-alt" aria-hidden="true"></i></span></div></div></div><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/2019/01/31/python中的默认参数陷阱/" rel="next" title="python中的默认参数陷阱"><i class="fa fa-chevron-left"></i> python中的默认参数陷阱</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"><a href="/2019/02/09/详解YOLO系列算法/" rel="prev" title="详解YOLO系列">详解YOLO系列 <i class="fa fa-chevron-right"></i></a></div></div></footer></div></article></div></div><div class="comments" id="comments"></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span> <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span> <span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">文章目录</li><li class="sidebar-nav-overview" data-target="site-overview-wrap">站点概览</li></ul><div class="site-overview-wrap sidebar-panel"><div class="site-overview"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" src="/images/author.jpg" alt="黄飘"><p class="site-author-name" itemprop="name">黄飘</p><p class="site-description motion-element" itemprop="description">直到这一刻微笑着说话为止，我至少留下了一公升眼泪</p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">44</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/index.html"><span class="site-state-item-count">16</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/index.html"><span class="site-state-item-count">49</span> <span class="site-state-item-name">标签</span></a></div></nav><div class="feed-link motion-element"><a href="/atom.xml" rel="alternate"><i class="fa fa-rss"></i> RSS</a></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/nightmaredimple" title="GitHub &rarr; https://github.com/nightmaredimple" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a> </span><span class="links-of-author-item"><a href="https://blog.csdn.net/nightmare_dimple" title="CSDN &rarr; https://blog.csdn.net/nightmare_dimple" rel="noopener" target="_blank"><i class="fa fa-fw fa-crosshairs"></i>CSDN</a> </span><span class="links-of-author-item"><a href="/huangpiao2985@163.com" title="E-Mail &rarr; huangpiao2985@163.com"><i class="fa fa-fw fa-envelope"></i>E-Mail</a> </span><span class="links-of-author-item"><a href="https://www.zhihu.com/people/huang-piao-72/posts" title="ZhiHu &rarr; https://www.zhihu.com/people/huang-piao-72/posts" rel="noopener" target="_blank"><i class="fa fa-fw fa-zhihu"></i>ZhiHu</a></span></div><div class="cc-license motion-element" itemprop="license"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a></div></div></div><div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#前言"><span class="nav-text">前言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-岭回归理论推导"><span class="nav-text">1.岭回归理论推导</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-循环矩阵"><span class="nav-text">2. 循环矩阵</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-循环矩阵的引入"><span class="nav-text">2.1 循环矩阵的引入</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-循环矩阵的转换"><span class="nav-text">2.2 循环矩阵的转换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-二维循环矩阵"><span class="nav-text">2.3 二维循环矩阵</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-循环矩阵与岭回归算法的结合"><span class="nav-text">3. 循环矩阵与岭回归算法的结合</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-对偶空间的引入"><span class="nav-text">4. 对偶空间的引入</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-优化角度分析"><span class="nav-text">4.1 优化角度分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-矩阵变换角度"><span class="nav-text">4.2 矩阵变换角度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-新样本测试"><span class="nav-text">4.3 新样本测试</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-核函数的高维映射"><span class="nav-text">5.核函数的高维映射</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1核函数的引入"><span class="nav-text">5.1核函数的引入</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-核函数与循环矩阵的结合"><span class="nav-text">5.2 核函数与循环矩阵的结合</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-3-不同核函数的计算"><span class="nav-text">5.3 不同核函数的计算</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-模板图像的获取"><span class="nav-text">6. 模板图像的获取</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-特征提取"><span class="nav-text">7.特征提取</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#7-1-f-hog特征"><span class="nav-text">7.1 f-hog特征</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-2-CN-CN2特征"><span class="nav-text">7.2 CN/CN2特征</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-算法实现"><span class="nav-text">8. 算法实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#8-1-多通道图像特征矩阵求解"><span class="nav-text">8.1 多通道图像特征矩阵求解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-2-标签制作"><span class="nav-text">8.2 标签制作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-3-多尺度检测"><span class="nav-text">8.3 多尺度检测</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-4-模板更新"><span class="nav-text">8.4 模板更新</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-总结"><span class="nav-text">9.总结</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#参考资料"><span class="nav-text">参考资料</span></a></li></ol></div></div></div><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span id="scrollpercent"><span>0</span>%</span></div></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div class="copyright">&copy; 2019 – <span itemprop="copyrightYear">2020</span> <span class="with-love" id="animate"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">黄飘</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-area-chart"></i> </span><span class="post-meta-item-text">站点总字数：</span> <span title="post.totalcount">128.2k字</span></div><div class="busuanzi-count"><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span class="post-meta-item-icon"><i class="fa fa-user"></i> </span><span class="site-uv" title="总访客量">总访客量: <span class="busuanzi-value" id="busuanzi_value_site_uv"></span> </span><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="site-pv" title="总访问量">总访问数: <span class="busuanzi-value" id="busuanzi_value_site_pv"></span></span></div></div></footer><div id="needsharebutton-float"><span class="btn"><i class="fa fa-share-alt" aria-hidden="true"></i></span></div></div><script>"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script color="0,0,0" opacity="0.5" zindex="-1" count="150" src="//cdn.bootcss.com/canvas-nest.js/1.0.1/canvas-nest.min.js"></script><script src="//cdn.jsdelivr.net/jquery/2.1.3/jquery.min.js"></script><script src="//cdn.jsdelivr.net/fastclick/1.0.6/fastclick.min.js"></script><script src="//cdn.jsdelivr.net/jquery.lazyload/1.9.3/jquery.lazyload.min.js"></script><script src="//cdn.jsdelivr.net/velocity/1.2.3/velocity.min.js"></script><script src="//cdn.jsdelivr.net/velocity/1.2.3/velocity.ui.min.js"></script><script src="/lib/reading_progress/reading_progress.js"></script><script src="/js/src/utils.js?v=6.7.0"></script><script src="/js/src/motion.js?v=6.7.0"></script><script src="/js/src/affix.js?v=6.7.0"></script><script src="/js/src/schemes/pisces.js?v=6.7.0"></script><script src="/js/src/scrollspy.js?v=6.7.0"></script><script src="/js/src/post-details.js?v=6.7.0"></script><script src="/js/src/bootstrap.js?v=6.7.0"></script><script src="//cdn1.lncld.net/static/js/3.11.1/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><script>var GUEST=["nick","mail","link"],guest="nick";guest=guest.split(",").filter(function(e){return GUEST.indexOf(e)>-1}),new Valine({el:"#comments",verify:!1,notify:!1,appId:"YGYUrzPLBQI94NtQWvTjzrE5-gzGzoHsz",appKey:"aQseSeSwrta45i3gUrcNK2QQ",placeholder:"ヾﾉ≧∀≦)o 来呀！吐槽一番吧！",avatar:"mm",meta:guest,pageSize:"10",visitor:!1})</script><script>function proceedsearch(){$("body").append('<div class="search-popup-overlay local-search-pop-overlay"></div>').css("overflow","hidden"),$(".search-popup-overlay").click(onPopupClose),$(".popup").toggle();var e=$("#local-search-input");e.attr("autocapitalize","none"),e.attr("autocorrect","off"),e.focus()}var isfetched=!1,isXml=!0,search_path="search.xml";0===search_path.length?search_path="search.xml":/json$/i.test(search_path)&&(isXml=!1);var path="/"+search_path,onPopupClose=function(e){$(".popup").hide(),$("#local-search-input").val(""),$(".search-result-list").remove(),$("#no-result").remove(),$(".local-search-pop-overlay").remove(),$("body").css("overflow","")},searchFunc=function(e,t,o){"use strict";$("body").append('<div class="search-popup-overlay local-search-pop-overlay"><div id="search-loading-icon"><i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i></div></div>').css("overflow","hidden"),$("#search-loading-icon").css("margin","20% auto 0 auto").css("text-align","center"),$.ajax({url:e,dataType:isXml?"xml":"json",async:!0,success:function(e){isfetched=!0,$(".popup").detach().appendTo(".header-inner");var n=isXml?$("entry",e).map(function(){return{title:$("title",this).text(),content:$("content",this).text(),url:$("url",this).text()}}).get():e,r=document.getElementById(t),s=document.getElementById(o),a=function(){var e=r.value.trim().toLowerCase(),t=e.split(/[\s\-]+/);t.length>1&&t.push(e);var o=[];if(e.length>0&&n.forEach(function(n){function r(t,o,n,r){for(var s=r[r.length-1],a=s.position,i=s.word,l=[],h=0;a+i.length<=n&&0!=r.length;){i===e&&h++,l.push({position:a,length:i.length});var p=a+i.length;for(r.pop();0!=r.length&&(s=r[r.length-1],a=s.position,i=s.word,p>a);)r.pop()}return c+=h,{hits:l,start:o,end:n,searchTextCount:h}}function s(e,t){var o="",n=t.start;return t.hits.forEach(function(t){o+=e.substring(n,t.position);var r=t.position+t.length;o+='<b class="search-keyword">'+e.substring(t.position,r)+"</b>",n=r}),o+=e.substring(n,t.end)}var a=!1,i=0,c=0,l=n.title.trim(),h=l.toLowerCase(),p=n.content.trim().replace(/<[^>]+>/g,""),u=p.toLowerCase(),f=decodeURIComponent(n.url).replace(/\/{2,}/g,"/"),d=[],g=[];if(""!=l&&(t.forEach(function(e){function t(e,t,o){var n=e.length;if(0===n)return[];var r=0,s=[],a=[];for(o||(t=t.toLowerCase(),e=e.toLowerCase());(s=t.indexOf(e,r))>-1;)a.push({position:s,word:e}),r=s+n;return a}d=d.concat(t(e,h,!1)),g=g.concat(t(e,u,!1))}),(d.length>0||g.length>0)&&(a=!0,i=d.length+g.length)),a){[d,g].forEach(function(e){e.sort(function(e,t){return t.position!==e.position?t.position-e.position:e.word.length-t.word.length})});var v=[];0!=d.length&&v.push(r(l,0,l.length,d));for(var $=[];0!=g.length;){var C=g[g.length-1],m=C.position,x=C.word,w=m-20,y=m+80;w<0&&(w=0),y<m+x.length&&(y=m+x.length),y>p.length&&(y=p.length),$.push(r(p,w,y,g))}$.sort(function(e,t){return e.searchTextCount!==t.searchTextCount?t.searchTextCount-e.searchTextCount:e.hits.length!==t.hits.length?t.hits.length-e.hits.length:e.start-t.start});var T=parseInt("3");T>=0&&($=$.slice(0,T));var b="";b+=0!=v.length?"<li><a href='"+f+"' class='search-result-title'>"+s(l,v[0])+"</a>":"<li><a href='"+f+"' class='search-result-title'>"+l+"</a>",$.forEach(function(e){b+="<a href='"+f+'\'><p class="search-result">'+s(p,e)+"...</p></a>"}),b+="</li>",o.push({item:b,searchTextCount:c,hitCount:i,id:o.length})}}),1===t.length&&""===t[0])s.innerHTML='<div id="no-result"><i class="fa fa-search fa-5x"></i></div>';else if(0===o.length)s.innerHTML='<div id="no-result"><i class="fa fa-frown-o fa-5x"></i></div>';else{o.sort(function(e,t){return e.searchTextCount!==t.searchTextCount?t.searchTextCount-e.searchTextCount:e.hitCount!==t.hitCount?t.hitCount-e.hitCount:t.id-e.id});var a='<ul class="search-result-list">';o.forEach(function(e){a+=e.item}),a+="</ul>",s.innerHTML=a}};r.addEventListener("input",a),$(".local-search-pop-overlay").remove(),$("body").css("overflow",""),proceedsearch()}})};$(".popup-trigger").click(function(e){e.stopPropagation(),isfetched===!1?searchFunc(path,"local-search-input","local-search-result"):proceedsearch()}),$(".popup-btn-close").click(onPopupClose),$(".popup").click(function(e){e.stopPropagation()}),$(document).on("keyup",function(e){var t=27===e.which&&$(".search-popup").is(":visible");t&&onPopupClose()})</script><script>!function(){var t=document.createElement("script"),s=window.location.protocol.split(":")[0];"https"===s?t.src="https://zz.bdstatic.com/linksubmit/push.js":t.src="http://push.zhanzhang.baidu.com/push.js";var e=document.getElementsByTagName("script")[0];e.parentNode.insertBefore(t,e)}()</script><script type="text/x-mathjax-config">MathJax.Ajax.config.path['mhchem'] = '//cdnjs.cloudflare.com/ajax/libs/mathjax-mhchem/3.3.0';
  

  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true,
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
      
        extensions: ['[mhchem]/mhchem.js'],
      
      equationNumbers: {
        autoNumber: "AMS"
      }
    }
  });</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
      for (i = 0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
      }
  });</script><script src="//cdn.jsdelivr.net/npm/mathjax@2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><style>.MathJax_Display{overflow:auto hidden}</style><script src="/lib/needsharebutton/needsharebutton.js"></script><script>pbOptions={},pbOptions.iconStyle="box",pbOptions.boxForm="horizontal",pbOptions.position="bottomCenter",pbOptions.networks="Weibo,Wechat,Douban,QQZone,Twitter,Facebook",new needShareButton("#needsharebutton-postbottom",pbOptions),flOptions={},flOptions.iconStyle="box",flOptions.boxForm="horizontal",flOptions.position="middleRight",flOptions.networks="Weibo,Wechat,Douban,QQZone,Twitter,Facebook",new needShareButton("#needsharebutton-float",flOptions)</script><style>.copy-btn{display:inline-block;padding:6px 12px;font-size:13px;font-weight:700;line-height:20px;color:#333;white-space:nowrap;vertical-align:middle;cursor:pointer;background-color:#eee;background-image:linear-gradient(#fcfcfc,#eee);border:1px solid #d5d5d5;border-radius:3px;user-select:none;outline:0}.highlight-wrap .copy-btn{transition:opacity .3s ease-in-out;opacity:0;padding:2px 6px;position:absolute;right:4px;top:8px}.highlight-wrap .copy-btn:focus,.highlight-wrap:hover .copy-btn{opacity:1}.highlight-wrap{position:relative}</style><script>$(".highlight").each(function(e,t){var n=$("<div>").addClass("highlight-wrap");$(t).after(n),n.append($("<button>").addClass("copy-btn").append("复制").on("click",function(e){var t=$(this).parent().find(".code").find(".line").map(function(e,t){return $(t).text()}).toArray().join("\n"),n=document.createElement("textarea"),o=document.createRange(),a=window.getSelection(),i=window.pageYOffset||document.documentElement.scrollTop;n.style.top=i+"px",n.style.position="absolute",n.style.opacity="0",n.value=t,n.textContent=t,n.contentEditable=!0,n.readOnly=!1,document.body.appendChild(n),o.selectNode(n),a.removeAllRanges(),a.addRange(o),n.setSelectionRange(0,t.length);var d=document.execCommand("copy");d?$(this).text("复制成功"):$(this).text("复制失败"),n.blur(),$(this).blur()})).on("mouseleave",function(e){var t=$(this).find(".copy-btn");setTimeout(function(){t.text("复制")},300)}).append(t)})</script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({pluginRootPath:"live2dw/",pluginJsPath:"lib/",pluginModelPath:"assets/",tagMode:!1,model:{jsonPath:"/live2dw/assets/wanko.model.json"},display:{position:"right",width:150,height:300},mobile:{show:!1},log:!1})</script><script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax":{"inlineMath":[["$","$"],["\\(","\\)"]],"skipTags":["script","noscript","style","textarea","pre","code"],"processEscapes":true},"TeX":{"equationNumbers":{"autoNumber":"AMS"}}});</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js"></script></body></html><script type="text/javascript" src="/js/src/clicklove.js"></script><!-- rebuild by neat -->